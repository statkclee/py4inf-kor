<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="hevea 2.09" />
<link rel="stylesheet" type="text/css" href="book.css" />
<title>리스트 (List)</title>
</head>
<body>
<a href="book009.html"><img src="previous_motif.gif" alt="Previous" /></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up" /></a>
<a href="book011.html"><img src="next_motif.gif" alt="Next" /></a>
<hr />
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="  xwMOOC와 함께 정보 불평등(digital divide)을 해소하는 것을 넘어 기회로 바꾸세요!" />
<title> 불평등(Digital Divide)을 "기회"로. </title>
<!-- stylesheets -->
<link media="all" href="http://netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" />
<link media="all" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
<link media="all" rel="stylesheet" href="/assets/css/site.css" />
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-59802572-1', 'auto');
    ga('send', 'pageview');

  </script>
</head>
<h1 id="sec101" class="chapter"><span style="font-weight:bold;font-size:medium;color:black">Chapter 9  리스트 (List)</span></h1>
<p><a id="hevea_default446"></a><span style="font-size:medium">
</span><a id="hevea_default447"></a></p><span style="font-size:medium">
</span><h2 id="sec102" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.1  리스트는 순서(sequence)다.</span></h2>
<p><span style="font-weight:bold;font-size:medium;color:black">문자열처럼, 리스트(list)는 값의 순서(sequence)다. 
문자열에서, 값은 문자지만, 리스트에서는 임의 자료형(type)도 될 수 있다.
리스트 값은 요소(elements)나 때때로 항목(items)으로 불린다.</span></p><p><a id="hevea_default448"></a><span style="font-size:medium">
</span><a id="hevea_default449"></a><span style="font-size:medium">
</span><a id="hevea_default450"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">신규 리스틀 생성하는 방법은 여러 가지가 있다. 
가장 간단한 방법은 꺾쇠 괄호(<code>[</code> 와 <code>]</code>)로 요소를 감싸는 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">첫번째 예제는 4개 정수 리스트다. 
두번째 예제는 3개 문자열 리스트다.
문자열 요소가 동일한 자료형(type)일 필요는 없다. 
다음 리스트는 문자열, 부동 소수점 숫자, 정수, (아!) 또 다른 리스트를 담고 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">['spam', 2.0, 5, [10, 20]]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">또 다른 리스트 내부에 리스트가 중첩(nested)되어 있다.</span></p><p><a id="hevea_default451"></a><span style="font-size:medium">
</span><a id="hevea_default452"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">어떤 요소도 담고 있지 않는 리스트를 빈 리스트(empty list)라고 부르고, 빈 꺾쇠 괄호(”[]”)로 생성한다.</span></p><p><a id="hevea_default453"></a><span style="font-size:medium">
</span><a id="hevea_default454"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">예상했듯이, 리스트 값을 변수에 대입할 수 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; print cheeses, numbers, empty
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
</span></pre><p><a id="hevea_default455"></a></p><span style="font-size:medium">
</span><h2 id="sec103" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.2  리스트는 변경가능하다.</span></h2>
<p><a id="hevea_default456"></a><span style="font-size:medium">
</span><a id="hevea_default457"></a><span style="font-size:medium">
</span><a id="hevea_default458"></a><span style="font-size:medium">
</span><a id="hevea_default459"></a><span style="font-size:medium">
</span><a id="hevea_default460"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트 요소에 접근하는 구문은 문자열 문자에 접근하는 것과 동일한 꺾쇠 괄호 연산자다.
꺽쇠 괄호 내부 표현식은 인덱스를 명세한다. 기억할 것은 인덱스는 0 에서부터 시작한다는 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; print cheeses[0]
Cheddar
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">문자열과 달리, 리스트 항목 순서를 바꾸거나, 리스트에 새로운 항목을 다시 대입할 수 있기 때문에 리스트는 변경가능하다.
꺾쇠 괄호 연산자가 대입문 왼쪽편에 나타날 때, 새로 대입될 리스트 요소를 나타낸다.</span></p><p><a id="hevea_default461"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; print numbers
[17, 5]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트 <span style="font-family:monospace">numbers</span> 첫번째 요소는 123 값을 가지고 있었으나, 이제 5 값을 가진다.</span></p><p><a id="hevea_default462"></a><span style="font-size:medium">
</span><a id="hevea_default463"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트를 인덱스와 요소의 관계로 생각할 수 있다. 
이 관계를 매핑(mapping)이라고 부른다. 
각각의 인덱스는 요소 중 하나에 대응(”maps to”)된다.</span></p><p><a id="hevea_default464"></a><span style="font-size:medium">
</span><a id="hevea_default465"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트 인덱스는 문자열 인덱스와 동일한 방식으로 동작한다.</span></p><ul class="itemize"><li class="li-itemize"><span style="font-weight:bold;font-size:medium;color:black">어떠한 정수 표현식도 인덱스로 사용할 수 있다.</span></li><li class="li-itemize"><span style="font-weight:bold;font-size:medium;color:black">존재하지 않는 요소를 읽거나 쓰려고 하면, <span style="font-family:monospace">인덱스 오류 (IndexError)</span>가 발생한다.</span><p><a id="hevea_default466"></a><span style="font-size:medium">
</span><a id="hevea_default467"></a></p></li><li class="li-itemize"><span style="font-weight:bold;font-size:medium;color:black">인덱스가 음의 값이면, 리스트 끝에서부터 역으로 센다.</span></li></ul><p><a id="hevea_default468"></a></p><p><a id="hevea_default469"></a><span style="font-size:medium">
</span><a id="hevea_default470"></a><span style="font-size:medium">
</span><a id="hevea_default471"></a><span style="font-size:medium">
</span><a id="hevea_default472"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">in</span> 연산자도 또한 리스트에서 동작하니 사용할 수 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in cheeses
True
&gt;&gt;&gt; 'Brie' in cheeses
False
</span></pre><span style="font-size:medium">
</span><h2 id="sec104" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.3  리스트 운행법</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default473"></a><span style="font-size:medium">
</span><a id="hevea_default474"></a><span style="font-size:medium">
</span><a id="hevea_default475"></a><span style="font-size:medium">
</span><a id="hevea_default476"></a><span style="font-size:medium">
</span><a id="hevea_default477"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트 요소를 운행하는 가장 흔한 방법은 <span style="font-family:monospace">for</span>문을 사용하는 것이다.
문자열에서 사용한 것과 구문은 동일하다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">for cheese in cheeses:
    print cheese
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트 요소를 읽기만 한다면 이것만으로도 잘 동작한다. 
하지만, 리스트 요소를 쓰거나, 갱신하는 경우, 인텍스가 필요하다. 
리스트 요소를 쓰거나 갱신하는 일반적인 방법은 <span style="font-family:monospace">range</span>와 <span style="font-family:monospace">len</span> 함수를 조합하는 것이다.</span></p><p><a id="hevea_default478"></a><span style="font-size:medium">
</span><a id="hevea_default479"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
</span></pre><p><span style="font-size:medium;color:black"><span style="font-weight:bold">상기 루프는 리스트를 운행하고 각 요소를 갱신한다. 
<span style="font-family:monospace">len</span> 함수는 리스트 요소 갯수를 반환한다.
<span style="font-family:monospace">range</span> 함수는 0 에서 </span><span style="font-style:italic">n</span>−1<span style="font-weight:bold"> 까지 리스트 인텍스를 반환한다. 
여기서, </span><span style="font-style:italic">n</span><span style="font-weight:bold">은 리스트 길이다.
매번 루프가 반복될 때마다, <span style="font-family:monospace">i</span>는 다음 요소 인덱스를 얻는다. 
몸통 부문 대입문은 <span style="font-family:monospace">i</span>를 사용해서 요소의 이전 값을 읽고 새 값을 대입한다.</span></span></p><p><a id="hevea_default480"></a><span style="font-size:medium">
</span><a id="hevea_default481"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">빈 리스트에 대해서 <span style="font-family:monospace">for</span>문은 결코 몸통 부문을 실행하지 않는다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">for x in empty:
    print 'This never happens.'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트가 또 다른 리스트를 담을 수 있지만, 중첩된 리스트는 여전히 요소 하나로 간주된다. 
다음 리스트 길이는 4 이다.</span></p><p><a id="hevea_default482"></a><span style="font-size:medium">
</span><a id="hevea_default483"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</span></pre><span style="font-size:medium">
</span><h2 id="sec105" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.4  리스트 연산자</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default484"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">+</span> 연산자는 리스트를 결합한다.</span></p><p><a id="hevea_default485"></a><span style="font-size:medium">
</span><a id="hevea_default486"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print c
[1, 2, 3, 4, 5, 6]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">유사하게 <span style="font-family:monospace">*</span> 연산자는 주어진 횟수만큼 리스트를 반복한다.</span></p><p><a id="hevea_default487"></a><span style="font-size:medium">
</span><a id="hevea_default488"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">첫 예제는 <span style="font-family:monospace">[0]</span>을 4회 반복한다. 
두 번째 예제는 <span style="font-family:monospace">[1, 2, 3]</span> 리스트를 3회 반복한다.</span></p><span style="font-size:medium">
</span><h2 id="sec106" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.5  리스트 슬라이스(List slices)</span></h2>
<p><a id="hevea_default489"></a><span style="font-size:medium">
</span><a id="hevea_default490"></a><span style="font-size:medium">
</span><a id="hevea_default491"></a><span style="font-size:medium">
</span><a id="hevea_default492"></a><span style="font-size:medium">
</span><a id="hevea_default493"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">슬라이스 연산자는 리스트에도 또한 동작한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">첫 번째 인덱스를 생략하면, 슬라이스는 처음부터 시작한다. 
두 번째 인덱스를 생략하면, 슬라이스는 끝까지 간다.
그래서 양쪽의 인덱스를 생략하면, 슬라이스 결과는 전체 리스트를 복사한 것이 된다.</span></p><p><a id="hevea_default494"></a><span style="font-size:medium">
</span><a id="hevea_default495"></a><span style="font-size:medium">
</span><a id="hevea_default496"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트는 변경이 가능하기 때문에 리스트를 접고, 돌리고, 훼손하는 연산을 수행하기 전에 복사본을 만들어 두는 것이 유용하다.</span></p><p><a id="hevea_default497"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">대입문 왼편의 슬라이스 연산자로 복수의 요소를 갱신할 수 있다.</span></p><p><a id="hevea_default498"></a><span style="font-size:medium">
</span><a id="hevea_default499"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; print t
['a', 'x', 'y', 'd', 'e', 'f']
</span></pre><span style="font-size:medium">
</span><h2 id="sec107" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.6  리스트 메쏘드</span></h2>
<p><a id="hevea_default500"></a><span style="font-size:medium">
</span><a id="hevea_default501"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">파이썬은 리스트에 연산하는 메쏘드를 제공한다. 
예를 들어, <span style="font-family:monospace">덧붙이기 (append)</span> 메쏘드는 리스트 끝에 신규 요소를 추가한다.</span></p><p><a id="hevea_default502"></a><span style="font-size:medium">
</span><a id="hevea_default503"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; print t
['a', 'b', 'c', 'd']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">확장 (extend)</span> 메쏘드는 인자로 리스트를 받아 모든 요소를 리스트에 덧붙인다.</span></p><p><a id="hevea_default504"></a><span style="font-size:medium">
</span><a id="hevea_default505"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; print t1
['a', 'b', 'c', 'd', 'e']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 예제는 <span style="font-family:monospace">t2</span> 리스트를 변경없이 그냥 둔다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">정렬 (sort)</span> 메쏘드는 낮음에서 높음으로 리스트 요소를 정렬한다.</span></p><p><a id="hevea_default506"></a><span style="font-size:medium">
</span><a id="hevea_default507"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; print t
['a', 'b', 'c', 'd', 'e']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">대부분의 리스트 메쏘드는 보이드(void)여서, 리스트를 변경하고 <span style="font-family:monospace">None</span>을 반환한다.
우연히 <span style="font-family:monospace">t = t.sort()</span> 이렇게 작성한다면, 결과에 실망할 것이다.</span></p><p><a id="hevea_default508"></a><span style="font-size:medium">
</span><a id="hevea_default509"></a><span style="font-size:medium">
</span><a id="hevea_default510"></a><span style="font-size:medium">
</span><a id="hevea_default511"></a></p><span style="font-size:medium">
</span><h2 id="sec108" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.7  요소 삭제</span></h2>
<p><a id="hevea_default512"></a><span style="font-size:medium">
</span><a id="hevea_default513"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트 요소를 삭제하는 방법이 몇 가지 있다. 
리스트 요소 인덱스를 알고 있다면, <span style="font-family:monospace">팝 (pop)</span> 메쏘드를 사용한다.</span></p><p><a id="hevea_default514"></a><span style="font-size:medium">
</span><a id="hevea_default515"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; print t
['a', 'c']
&gt;&gt;&gt; print x
b
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">팝(pop)</span> 메쏘드는 리스트를 변경하여 제거된 요소를 반환한다.
인덱스를 주지 않으면, 마지막 요소를 지우고 반환한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">요소에서 제거된 값이 필요없다면, <span style="font-family:monospace">del</span> 연산자를 사용한다.</span></p><p><a id="hevea_default516"></a><span style="font-size:medium">
</span><a id="hevea_default517"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; print t
['a', 'c']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">(인덱스가 아닌) 제거할 요소값을 알고 있다면, <span style="font-family:monospace">제거 (remove)</span> 메쏘드를 사용한다.</span></p><p><a id="hevea_default518"></a><span style="font-size:medium">
</span><a id="hevea_default519"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; print t
['a', 'c']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">제거 (remove)</span> 메쏘드의 반환값은 <span style="font-family:monospace">None</span>이다.</span></p><p><a id="hevea_default520"></a><span style="font-size:medium">
</span><a id="hevea_default521"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">하나 이상의 요소를 제거하기 위해서, 슬라이스 인덱스(slice index)와 <span style="font-family:monospace">del</span>을 사용한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; print t
['a', 'f']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">마찬가지로, 슬라이스는 두 번째 인덱스를 포함하지 않는 두 번째 인덱스까지 모든 요소를 선택한다.</span></p><span style="font-size:medium">
</span><h2 id="sec109" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.8  리스트와 함수</span></h2>
<p><span style="font-weight:bold;font-size:medium;color:black">루프를 작성하지 않고도 리스트를 빠르게 살펴볼 수 있는 리스트에 적용할 수 있는 내장함수가 많이 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; nums = [3, 41, 12, 9, 74, 15]
&gt;&gt;&gt; print len(nums)
6
&gt;&gt;&gt; print max(nums)
74
&gt;&gt;&gt; print min(nums)
3
&gt;&gt;&gt; print sum(nums)
154
&gt;&gt;&gt; print sum(nums)/len(nums)
25
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트 요소가 숫자일 때만, <span style="font-family:monospace">sum()</span> 함수는 동작한다. 
<span style="font-family:monospace">max()</span>, <span style="font-family:monospace">len()</span>, 등등 다른 함수는 문자열 리스트나, 비교 가능한 다른 자료형(type) 리스트에 사용될 수 있다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트를 사용해서, 앞서 작성한 프로그램을 다시 작성해서 사용자가 입력한 숫자 목록 평균을 계산한다. </span></p><p><span style="font-weight:bold;font-size:medium;color:black">우선 리스트 없이 평균을 계산하는 프로그램:</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">total = 0
count = 0
while ( True ) :
    inp = raw_input('Enter a number: ')
    if inp == 'done' : break
    value = float(inp)
    total = total + value
    count = count + 1

average = total / count
print 'Average:', average
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 프로그램에서, <span style="font-family:monospace">count</span> 와 <span style="font-family:monospace">sum</span> 변수를 사용해서 반복적으로 사용자가 숫자를 입력하면 값을 저장하고, 
지금까지 사용자가 입력한 누적 합계를 계산한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">단순하게, 사용자가 입력한 각 숫자를 기억하고 내장함수를 사용해서 프로그램 마지막에 합계와 갯수를 계산한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">numlist = list()
while ( True ) :
    inp = raw_input('Enter a number: ')
    if inp == 'done' : break
    value = float(inp)
    numlist.append(value)

average = sum(numlist) / len(numlist)
print 'Average:', average
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">루프가 시작되기 전 빈 리스트를 생성하고, 매번 숫자를 입력할 때마다 숫자를 리스트에 추가한다.
프로그램 마지막에 간단하게 리스트 총합을 계산하고, 평균을 산출하기 위해서 입력한 숫자 개수로 나눈다.</span></p><span style="font-size:medium">
</span><h2 id="sec110" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.9  리스트와 문자열</span></h2>
<p><a id="hevea_default522"></a><span style="font-size:medium">
</span><a id="hevea_default523"></a><span style="font-size:medium">
</span><a id="hevea_default524"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">문자열은 문자 순서(sequence)이고, 리스트는 값 순서(sequence)이다. 
하지만 리스트 문자는 문자열과 같지는 않다. 
문자열에서 리스트 문자로 변환하기 위해서, <span style="font-family:monospace">list</span>를 사용한다.</span></p><p><a id="hevea_default525"></a><span style="font-size:medium">
</span><a id="hevea_default526"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; print t
['s', 'p', 'a', 'm']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">list</span>는 내장함수 이름이기 때문에, 변수명으로 사용하는 것을 피해야 한다.
<span style="font-family:monospace">l</span>을 사용하면 <span style="font-family:monospace">1</span> 처럼 보이기 때문에 피한다. 그래서, <span style="font-family:monospace">t</span>를 사용했다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">list</span> 함수는 문자열을 각각의 문자로 쪼갠다. 
문자열 단어로 쪼개려면, <span style="font-family:monospace">분할 (split)</span> 메쏘드를 사용할 수 있다.</span></p><p><a id="hevea_default527"></a><span style="font-size:medium">
</span><a id="hevea_default528"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; print t
['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; print t[2]
the
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">분할 (split)</span> 메쏘드를 사용해서 문자열을 리스트 토큰으로 쪼개면, 인덱스 연산자(’[]’)를 사용하여 리스트의 특정 단어를 볼 수 있다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">옵션 인자로 단어 경계로 어떤 문자를 사용할 것인지 지정하는데 사용되는 구분자 (delimiter)를 활용하여 <span style="font-family:monospace">분할 (split)</span> 메쏘드를 호출한다.
다음 예제는 구분자로 하이픈(’-’)을 사용한 사례다.</span></p><p><a id="hevea_default529"></a><span style="font-size:medium">
</span><a id="hevea_default530"></a><span style="font-size:medium">
</span><a id="hevea_default531"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; s.split(delimiter)
['spam', 'spam', 'spam']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">합병 (join)</span> 메쏘드는 <span style="font-family:monospace">분할 (split)</span> 메쏘드의 역이다. 
문자열 리스트를 받아 리스트 요소를 연결한다.
<span style="font-family:monospace">합병 (join)</span>은 문자열 메쏘드여서, 구분자를 호출하여 매개 변수로 넘길 수 있다.</span></p><p><a id="hevea_default532"></a><span style="font-size:medium">
</span><a id="hevea_default533"></a><span style="font-size:medium">
</span><a id="hevea_default534"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; delimiter.join(t)
'pining for the fjords'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기의 경우, 구분자가 공백 문자여서 <span style="font-family:monospace">결합 (join)</span> 메쏘드가 단어 사이에 공백을 넣는다.
공백없이 문자열을 결합하기 위해서, 구분자로 빈 문자열 <code>"</code>을 사용한다.</span></p><p><a id="hevea_default535"></a><span style="font-size:medium">
</span><a id="hevea_default536"></a></p><span style="font-size:medium">
</span><h2 id="sec111" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.10  라인 파싱하기(Parsing)</span></h2>
<p><span style="font-weight:bold;font-size:medium;color:black">파일을 읽을 때 통상, 단지 전체 라인을 출력하는 것 말고 뭔가 다른 것을 하고자 한다.
종종 ”흥미로운 라인을” 찾아서 라인을 파싱(parse)하여 흥미로운 <em> 부분</em>을 찾고자 한다.
“From ”으로 시작하는 라인에서 요일을 찾고자 하면 어떨까?</span></p><pre><span style="font-weight:bold;font-size:large;color:blue">
From stephen.marquard@uct.ac.za  Sat Jan  5 09:14:16 2008
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이런 종류의 문제에 직면했을 때, <span style="font-family:monospace">분할 (split)</span> 메쏘드가 매우 효과적이다.
작은 프로그램을 작성하여 ”From ”으로 시작하는 라인을 찾고 <span style="font-family:monospace">분할 (split)</span> 메쏘드로 파싱하고 라인의 흥미로운 부분을 출력한다. </span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From ') : continue
    words = line.split()
    print words[2]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">if</span> 문의 축약 형태를 사용하여 <span style="font-family:monospace">continue </span>문을 <span style="font-family:monospace">if</span>문과 동일한 라인에 놓았다.
<span style="font-family:monospace">if</span> 문 축약 형태는 <span style="font-family:monospace">continue </span>문을 들여쓰기를 다음 라인에 한 것과 동일하다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">프로그램은 다음을 출력한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">Sat
Fri
Fri
Fri
    ...
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">나중에, 매우 정교한 기술에 대해서 학습해서 정확하게 검색하는 비트(bit) 수준 정보를 찾아 내기 위해서 작업할 라인을 선택하고, 어떻게 해당 라인을 뽑아낼 것이다. </span></p><span style="font-size:medium">
</span><h2 id="sec112" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.11  객체와 값(value)</span></h2>
<p><a id="hevea_default537"></a><span style="font-size:medium">
</span><a id="hevea_default538"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">다음 대입문을 실행하면,</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">a = 'banana'
b = 'banana'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">a</span> 와 <span style="font-family:monospace">b</span> 모두 문자열을 참조하지만, 두 변수가 <em>동일한</em> 문자열을 참조하는지 알 수 없다.
두 가지 가능한 상태가 있다.</span></p><p><a id="hevea_default539"></a></p><div class="center"><span style="font-weight:bold;font-size:medium;color:black"><img src="book012.png" /></span></div><p><span style="font-weight:bold;font-size:medium;color:black">한 가지 경우는 <span style="font-family:monospace">a</span> 와 <span style="font-family:monospace">b</span>가 같은 값을 가지는 다른 두 객체를 참조하는 것이다. 
두 번째 경우는 같은 객체를 참조하는 것이다.</span></p><p><a id="hevea_default540"></a><span style="font-size:medium">
</span><a id="hevea_default541"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">두 변수가 동일한 객체를 참조하는지를 확인하기 위해서, <span style="font-family:monospace">is</span> 연산자가 사용된다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이 경우, 파이썬은 하나의 문자열 객체를 생성하고 <span style="font-family:monospace">a</span> 와 <span style="font-family:monospace">b</span> 모두 동일한 객체를 참조한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">하지만, 리스트 두 개를 생성할 때, 객체가 두 개다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기의 경우, 두 개의 리스트는 동등하다고 말할 수 있다. 
왜냐하면 동일한 요소를 가지고 있기 때문이다.
하지만, 같은 객체는 아니기 때문에 동일하지는 않다. 
두 개의 객체가 동일하다면, 두 객체는 또한 등등하다.
하지만, 동등하다고 해서 반듯이 동일하지는 않다.</span></p><p><a id="hevea_default542"></a><span style="font-size:medium">
</span><a id="hevea_default543"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">지금까지 ”객체(object)”와 ”값(value)”을 구분 없이 사용했지만, 객체가 값을 가진다라고 말하는 것이 좀더 정확하다.
<span style="font-family:monospace">a = [1,2,3]</span> 을 실행하면, <span style="font-family:monospace">a</span> 는 특별한 순서 요소값을 갖는 리스트 객체로 참조한다. 
만약 또 다른 리스트가 동일한 요소를 가진다면, 그 리스트는 같은 값을 가진다고 말한다.</span></p><p><a id="hevea_default544"></a><span style="font-size:medium">
</span><a id="hevea_default545"></a></p><span style="font-size:medium">
</span><h2 id="sec113" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.12  에일리어싱(Aliasing)</span></h2>
<p><a id="hevea_default546"></a><span style="font-size:medium">
</span><a id="hevea_default547"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">a</span>가 객체를 참조하고, <span style="font-family:monospace">b = a</span> 대입하다면, 두 변수는 동일한 객체를 참조한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">객체와 변수의 연관짖는 것을 참조(reference)라고 한다. 
상기의 경우 동일한 객체에 두 개의 참조가 있다.</span></p><p><a id="hevea_default548"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">하나 이상의 참조를 가진 객체는 한개 이상의 이름을 갖게 되어서, 객체가 에일리어스(aliased) 되었다고 한다.</span></p><p><a id="hevea_default549"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">만약 에일리어스된 객체가 변경 가능하면, 변화의 여파는 다른 객체에도 파급된다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; b[0] = 17
&gt;&gt;&gt; print a
[17, 2, 3]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이와 같은 행동이 유용하기도 하지만, 오류를 발생시키기도 쉽다. 
일반적으로, 변경가능한 객체(mutable object)로 작업할 때 에일리어싱을 피하는 것이 안전하다.</span></p><p><a id="hevea_default550"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">문자열 같이 변경 불가능한 객체에 에일리어싱은 그렇게 문제가 되지 않는다. </span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">a = 'banana'
b = 'banana'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 예제에서, <span style="font-family:monospace">a</span> 와 <span style="font-family:monospace">b</span>가 동일한 문자열을 참조하든 참조하지 않든 거의 차이가 없다.</span></p><span style="font-size:medium">
</span><h2 id="sec114" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.13  리스트 인수</span></h2>
<p><a id="hevea_default551"></a><span style="font-size:medium">
</span><a id="hevea_default552"></a><span style="font-size:medium">
</span><a id="hevea_default553"></a><span style="font-size:medium">
</span><a id="hevea_default554"></a><span style="font-size:medium">
</span><a id="hevea_default555"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트를 함수에 인자로 전달할 때, 함수는 리스트에 참조를 얻는다. 
만약 함수가 리스트 매개 변수를 변경한다면, 호출자는 변경된 것을 보게된다.
예를 들어, <code>delete_head</code>는 리스트에서 첫 요소를 제거한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">def delete_head(t):
    del t[0]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">다음에 <code>delete_head</code> 함수가 사용된 예제가 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; delete_head(letters)
&gt;&gt;&gt; print letters
['b', 'c']
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">매개 변수 <span style="font-family:monospace">t</span>와 변수 <span style="font-family:monospace">letters</span>는 동일한 객체에 대한 에일리어스(aliases)다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트를 변경하는 연산자와 신규 리스트를 생성하는 연산자를 구별하는 것이 중요하다.
예를 들어, <span style="font-family:monospace">덧붙이기 (append)</span> 메쏘드는 리스트를 변경하지만, <span style="font-family:monospace">+</span> 연산자는 신규 리스트를 생성한다.</span></p><p><a id="hevea_default556"></a><span style="font-size:medium">
</span><a id="hevea_default557"></a><span style="font-size:medium">
</span><a id="hevea_default558"></a><span style="font-size:medium">
</span><a id="hevea_default559"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; print t1
[1, 2, 3]
&gt;&gt;&gt; print t2
None

&gt;&gt;&gt; t3 = t1 + [3]
&gt;&gt;&gt; print t3
[1, 2, 3]
&gt;&gt;&gt; t2 is t3
False
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">리스트를 변경하는 함수를 작성할 때, 이 차이는 매우 중요하다.
예를 들어, 다음 함수는 리스트의 머리 부문(head)을 삭제하지 않는다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">def bad_delete_head(t):
    t = t[1:]              # 틀림(WRONG)!
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">슬라이스 연산자는 새로운 리스트를 생성하고 대입문을 통해서 <span style="font-family:monospace">t</span>가 참조하게 하지만, 어떤 것도 인자로 전달된 리스트에는 영향도 주지 못한다.</span></p><p><a id="hevea_default560"></a><span style="font-size:medium">
</span><a id="hevea_default561"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">대안은 신규 리스트를 생성하고 반환하는 함수를 작성하는 것이다. 
예를 들어, <span style="font-family:monospace">tail</span>은 리스트의 첫 요소를 제외하고 모든 요소를 반환한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">def tail(t):
    return t[1:]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 함수는 원 리시트를 변경하지는 않는다. 
다음에 사용 예시가 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; rest = tail(letters)
&gt;&gt;&gt; print rest
['b', 'c']
</span></pre><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 1  </span><p><span style="font-weight:bold;font-size:medium;color:black"><em>리스트를 인자로 받아 리스트를 변경하여, 첫 번째 요소와 마지막 요소를 제거하고 <span style="font-family:monospace">None</span>을 반환하는 <span style="font-family:monospace">chop</span> 함수를 작성하게요.</em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>그리고 나서, 리스트를 인자로 받아 처음과 마지막 요소를 제외한 나머지 요소를 새로운 리스트로 반환하는 <span style="font-family:monospace">middle</span> 함수를 작성하세요.</em></span></p></div><span style="font-size:medium">
</span><h2 id="sec115" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.14  디버깅</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default562"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">부주의한 리스트 사용이나 변경가능한 객체를 사용하는 경우 디버깅을 오래 할 수 있다.
다음에 일반적인 함정 유형과 회피하는 방법을 소개한다.</span></p><ol class="enumerate" type="1"><li class="li-enumerate"><span style="font-weight:bold;font-size:medium;color:black">대부분의 리스트 메쏘드는 인자를 변경하고, <span style="font-family:monospace">None</span>을 반환한다. 이는 새로운 문자열을 반환하고 원 문자열은 그대로 두는 문자열의 경우와 정반대다.</span><p><span style="font-weight:bold;font-size:medium;color:black">다음과 같이 문자열 코드를 쓰는데 익숙해져 있다면,</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">word = word.strip()
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">다음과 같이 리스트 코드를 작성하고 싶은 유혹이 있을 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">t = t.sort()           # 틀림(WRONG)!
</span></pre><p><a id="hevea_default563"></a><span style="font-size:medium">
</span><a id="hevea_default564"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">정렬 (sort)</span> 메쏘드는 <span style="font-family:monospace">None</span>을 반환하기 때문에, 리스트 <span style="font-family:monospace">t</span>로 수행한 다음 연산은 실패한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">리스트 메쏘드와 연산자를 사용하기 전에, 문서를 주의깊게 읽고, 인터랙티브 모드에서 시험하는 것을 권한다.
리스트가 문자열과 같은 다른 순서(sequence)와 공유하는 메쏘드와 연산자는 <span style="font-family:monospace">docs.python.org/lib/typesseq.html</span> 에 문서화되어 있다.
변경가능한 순서(sequence)에만 적용되는 메쏘드와 연산자는 <span style="font-family:monospace">docs.python.org/lib/typesseq-mutable.html</span>에 문서화되어 있다.</span></p></li><li class="li-enumerate"><span style="font-weight:bold;font-size:medium;color:black">관용구를 선택하고 고수하라.
</span><a id="hevea_default565"></a><p><span style="font-weight:bold;font-size:medium;color:black">리스트와 관련된 문제 일부는 리스트를 가지고 할 수 있는 것이 너무 많다는 것이다.
예를 들어, 리스트에서 요소를 제거하기 위해서, <span style="font-family:monospace">pop</span>, <span style="font-family:monospace">remove</span>, <span style="font-family:monospace">del</span>, 혹은 슬라이스 대입(slice assignment)도 사용할 수 있다.
요소를 추가하기 위해서 <span style="font-family:monospace">덧붙이기 (append)</span> 메쏘드나 <span style="font-family:monospace">+</span> 연산자를 사용할 수 있다. 
하지만 다음이 맞다는 것을 잊지 마세요.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">t.append(x)
t = t + [x]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">하지만, 다음은 잘못됐다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">t.append([x])          # 틀림(WRONG)!
t = t.append(x)        # 틀림(WRONG)!
t + [x]                # 틀림(WRONG)!
t = t + x              # 틀림(WRONG)!
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">인터랙티브 모드에서 각각을 연습해 보고 제대로 이해하고 있는지 확인해 보세요.
마지막 한개만 실행 오류를 하고, 다른 세가지는 모두 작동하지만, 잘못된 것을 수행함을 주목하세요.</span></p></li><li class="li-enumerate"><span style="font-weight:bold;font-size:medium;color:black">에일리어싱을 회피하기 위해서 사본 만들기.</span><p><a id="hevea_default566"></a><span style="font-size:medium">
</span><a id="hevea_default567"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">인자를 변경하는 <span style="font-family:monospace">정렬 (sort)</span>같은 메쏘드를 사용하지만, 원 리스트도 보관되길 원한다면, 사본을 만든다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">orig = t[:]
t.sort()
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 예제에서 원 리스트는 그대로 둔 상태로 새로 정렬된 리스트를 반환하는 내장함수 <span style="font-family:monospace">sorted</span>를 사용할 수 있다.
하지만 이 경우에는, 변수명으로 <span style="font-family:monospace">sorted</span>를 사용하는 것을 피해야 한다!</span></p></li><li class="li-enumerate"><span style="font-weight:bold;font-size:medium;color:black">리스트, <span style="font-family:monospace">분할 (split)</span>, 파일</span><p><span style="font-weight:bold;font-size:medium;color:black">파일을 읽고 파싱할 때, 프로그램이 중단될 수 있는 입력값을 마주할 수많은 기회가 있다.
그래서 파일을 훑어 ”건초더미에서 바늘”을 찾는 프로그램을 작성할 때 사용한 가디언 패턴(guardian pattern)을 다시 살펴보는 것은 좋은 생각이다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">파일 라인에서 요일을 찾는 프로그램을 다시 살펴보자.</span></p><pre><span style="font-weight:bold;font-size:large;color:blue">
From stephen.marquard@uct.ac.za  Sat Jan  5 09:14:16 2008
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">각 라인을 단어로 나누었기 때문에, <span style="font-family:monospace">startswith</span>를 사용하지 않고, 라인에 관심있는 단어가 있는지 살펴보기 위해서 단순하게 각 라인의 첫 단어를 살펴본다.
다음과 같이 <span style="font-family:monospace">continue</span> 문을 사용해서 ”From”이 없는 라인을 건너 뛴다. </span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">fhand = open('mbox-short.txt')
for line in fhand:
    words = line.split()
    if words[0] != 'From' : continue
    print words[2]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">프로그램이 훨씬 간단하고, 파일 끝에 있는 새줄(newline)을 제거하기 위해 <span style="font-family:monospace">rstrip</span>을 사용할 필요도 없다.
하지만, 더 좋아졌는가?</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">python search8.py 
Sat
Traceback (most recent call last):
  File "search8.py", line 5, in &lt;module&gt;
    if words[0] != 'From' : continue
IndexError: list index out of range
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">작동하는 것 같지만, 첫줄에 Sat 를 출력하고 나서 역추적 오류(traceback error)로 프로그램이 정상 동작에 실패한다.
무엇이 잘못되었을까? 
어딘가 엉망이 된 데이터가 있어 우아하고, 총명하며, 매우 파이썬스러운 프로그램을 망가뜨린건가?</span></p><p><span style="font-weight:bold;font-size:medium;color:black">오랜 동안 프로그램을 응시하고 머리를 짜내거나, 다른 사람에게 도움을 요청할 수 있지만, 빠르고 현명한 접근법은 <span style="font-family:monospace">print</span>문을 추가하는 것이다.
<span style="font-family:monospace">print</span>문을 넣는 가장 좋은 장소는 프로그램이 동작하지 않는 라인 앞이 적절하고, 프로그램 실패를 야기할 것 같은 데이터를 출력한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">이 접근법이 많은 라인을 출력하지만, 즉석에서 문제에 대해서 손에 잡히는 단서는 최소한 준다. 
그래서 <span style="font-family:monospace">words</span>를 출력하는 출력문을 5번째 라인 앞에 추가한다. 
”Debug:”를 접두어로 라인에 추가하여, 정상적인 출력과 디버그 출력을 구분한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">for line in fhand:
    words = line.split()
    print 'Debug:', words
    if words[0] != 'From' : continue
    print words[2]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">프로그램을 실행할 때, 많은 출력결과가 스크롤되어 화면 위로 지나간다. 
마지막에 디버그 결과물과 역추적(traceback)을 보고 역추적(traceback) 바로 앞에서 무슨 일이 생겼는지 알 수 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">Debug: ['X-DSPAM-Confidence:', '0.8475']
Debug: ['X-DSPAM-Probability:', '0.0000']
Debug: []
Traceback (most recent call last):
  File "search9.py", line 6, in &lt;module&gt;
    if words[0] != 'From' : continue
IndexError: list index out of range
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">각 디버그 라인은 리스트 단어를 출력하는데, 라인을 <span style="font-family:monospace">분할 (split)</span>해서 단어로 만들 때 얻어진다.
프로그램이 실패할 때 리스트 단어는 비었다 ’[]’. 
텍스트 편집기로 파일을 열어 살펴보면 그 지점은 다음과 같다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">프로그램이 빈 라인을 만났을 때, 오류가 발생한다. 
물론, 빈 라인은 ’0’ 단어 (”zero words”)다.
프로그램을 작성할 때, 왜 이것을 생각하지 못했을까?
첫 단어(<code>word[0]</code>)가 ”From”과 일치하는지 코드가 점검할 때, “인덱스 범위 오류(index out of range)”가 발생한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">물론, 첫 단어가 없다면 첫 단어 점검을 회피하는 가디언 코드(guardian code)를 삽입하기 최적 장소이기는 하다.
코드를 보호하는 방법은 많다. 첫 단어를 살펴보기 전에 단어의 갯수를 확인하는 방법을 택한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">fhand = open('mbox-short.txt')
count = 0
for line in fhand:
    words = line.split()
    # print 'Debug:', words
    if len(words) == 0 : continue
    if words[0] != 'From' : continue
    print words[2]
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">변경한 코드가 실패해서 다시 디버그할 경우를 대비해서, <span style="font-family:monospace">print</span>문을 제거하는 대신에 <span style="font-family:monospace">print</span>문을 주석 처리한다.
그리고 나서, 단어가 ’0’ 인지를 살펴보고 만약 ’0’ 이면, 파일 다음 라인으로 건너뛰도록 <span style="font-family:monospace">continue</span>문을 사용하는 가디언 문장(guardian statement)을 추가한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">두 개 <span style="font-family:monospace">continue</span>문이 ”흥미롭고” 좀더 처리가 필요한 라인 집합을 정제하도록 돕는 것으로 생각할 수 있다.
단어가 없는 라인은 ”흥미 없어서” 다음 라인으로 건너뛴다. 첫 단어에 ”From”이 없는 라인도 ”흥미 없어서” 건너뛴다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">변경된 프로그램이 성공적으로 실행되어서, 아마도 올바르게 작성된 것으로 보인다. 
가디언 문장(guardian statement)이 <span style="font-family:monospace">words[0]</span>가 정상작동할 것이라는 것을 확인해 주지만, 충분하지 않을 수도 있다.
프로그램을 작성할 때, ”무엇이 잘못 될 수 있을까?”를 항상 생각해야만 한다.</span></p><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 2  <em>
상기 프로그램의 어느 라인이 여전히 적절하게 보호되지 않은지를 생각해 보세요.
텍스트 파일을 구성해서 프로그램이 실패하도록 만들 수 있는지 살펴보세요.
그리고 나서, 프로그램을 변경해서 라인이 적절하게 보호되게 하고, 
새로운 텍스트 파일을 잘 다룰 수 있도록 시험하세요.</em></span></div><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 3  <em>
두 <span style="font-family:monospace">if</span> 문 없이, 상기 예제의 <span style="font-family:monospace">가디언 코드(guardian code)</span>를 다시 작성하세요.
대신에 단일 <span style="font-family:monospace">if</span>문과 <span style="font-family:monospace">and</span> 논리 연산자를 사용하는 복합 논리 표현식을 사용하세요.
</em></span></div></li></ol><span style="font-size:medium">
</span><h2 id="sec116" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.15  용어정의</span></h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">에일리어싱(aliasing):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 하나 혹은 그 이상의 변수가 동일한 객체를 참조하는 상황.
</span><a id="hevea_default568"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">구분자(delimiter):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 문자열이 어디서 분할되어져야 할지를 표기하기 위해서 사용되는 문자나 문자열.
</span><a id="hevea_default569"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">요소(element):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 리스트 혹은 다른 순서(sequence) 값의 하나로 항목(item)이라고도 한다.
</span><a id="hevea_default570"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">동등한(equivalent):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 같은 값을 가짐.
</span><a id="hevea_default571"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">인덱스(index):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 리스트의 요소를 지칭하는 정수 값.
</span><a id="hevea_default572"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">동일한(identical):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 동등을 함축하는 같은 객체임.
</span><a id="hevea_default573"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">리스트(list):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 순서(sequence) 값.
</span><a id="hevea_default574"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">리스트 운행법(list traversal):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 리스트의 각 요소를 순차적으로 접근함.
</span><a id="hevea_default575"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">중첩 리스트(nested list):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 또 다른 리스트의 요소인 리스트.
</span><a id="hevea_default576"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">객체(object):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 변수가 참조할 수 있는 무엇. 객체는 자료형(type)과 값(value)을 가진다.
</span><a id="hevea_default577"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">참조(reference):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 변수와 값의 연관.
</span><a id="hevea_default578"></a></dd></dl><span style="font-size:medium">
</span><h2 id="sec117" class="section"><span style="font-weight:bold;font-size:medium;color:black">9.16  연습문제</span></h2>
<div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 4  </span><p><span style="font-weight:bold;font-size:medium;color:black"><em><span style="font-family:monospace">www.py4inf.com/code/romeo.txt</span>에서 파일 사본을 다운로드 받으세요.
</em></span><a id="hevea_default579"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><em><span style="font-family:monospace">romeo.txt</span> 파일을 열어, 한 줄씩 읽어들이는 프로그램을 작성하세요.
각 라인마다 <span style="font-family:monospace">분할 (split)</span> 함수를 사용하여 라인을 단어 리스트로 쪼개세요.</em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>각 단어마다, 단어가 이미 리스트에 존재하는지를 확인하세요. 
만약 단어가 리스트에 없다면, 리스트에 새 단어로 추가하세요.</em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>프로그램이 완료되면, 알파벳 순으로 결과 단어를 정렬하고 출력하세요.</em></span></p><pre class="verbatim"><span style="font-weight:bold;font-size:medium;color:black"><em>Enter file: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 
'and', 'breaks', 'east', 'envious', 'fair', 'grief', 
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 
'sun', 'the', 'through', 'what', 'window', 
'with', 'yonder']
</em></span></pre></div><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 5  </span><p><span style="font-weight:bold;font-size:medium;color:black"><em>전자우편 데이터를 읽어 들이는 프로그램을 작성하세요.
”From”으로 시작하는 라인을 발견했을 때, <span style="font-family:monospace">분할 (split)</span> 함수를 사용하여 라인을 단어로 쪼개세요.
”From” 라인의 두번째 단어, 누가 메시지를 보냈는지에 관심이 있다.</em></span></p><p><span style="font-family:monospace;font-weight:bold;font-size:medium;color:black"><em>From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008 </em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>”From” 라인을 파싱하여 각 ”From”라인의 두번째 단어를 출력한다.
그리고 나서, ”From:”이 아닌 ”From”라인 갯수를 세고, 끝에 갯수를 출력한다.</em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>여기 몇 줄을 삭제한 출력 예시가 있다.</em></span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue"><em>python fromcount.py 
Enter a file name: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
</em></span></pre></div><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 6  </span><p><span style="font-weight:bold;font-size:medium;color:black"><em>사용자가 숫자 리스트를 입력하고, 입력한 숫자 중에 최대값과 최소값을 출력하고 사용자가 ”done”을 입력할 때 종료하는 프로그램을 다시 작성하세요.
사용자가 입력한 숫자를 리스트에 저장하고, <span style="font-family:monospace">max()</span> 과 <span style="font-family:monospace">min()</span> 함수를 사용하여 루프가 끝나면, 최대값과 최소값을 출력하는 프로그램을 작성하세요.</em></span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue"><em>Enter a number: 6
Enter a number: 2
Enter a number: 9
Enter a number: 3
Enter a number: 5
Enter a number: done
Maximum: 9.0
Minimum: 2.0
</em></span></pre></div><span style="font-size:medium">
</span><footer class="footer">
<div class="container">
<div class="row">
<div class="col-lg-offset-3 col-lg-6">
<div class="row">
<div class="col-xs-12 text-center">
<small>&copy; rifyll theme, 2014, 
                Powered by <a href="http://www.ibm.com/cloud-computing/kr/ko/softlayer/"><img src="/img/softlayer.png" width="47" height="23" alt="hosting services" /></a> </small>
</div>
</div>
</div>
</div>
</div>
</footer>
<hr />
<a href="book009.html"><img src="previous_motif.gif" alt="Previous" /></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up" /></a>
<a href="book011.html"><img src="next_motif.gif" alt="Next" /></a>
</body>
</html>
