<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="hevea 2.09" />
<link rel="stylesheet" type="text/css" href="book.css" />
<title>문자열</title>
</head>
<body>
<a href="book007.html"><img src="previous_motif.gif" alt="Previous" /></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up" /></a>
<a href="book009.html"><img src="next_motif.gif" alt="Next" /></a>
<hr />
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="  xwMOOC와 함께 정보 불평등(digital divide)을 해소하는 것을 넘어 기회로 바꾸세요!" />
<title> 불평등(Digital Divide)을 "기회"로. </title>
<!-- stylesheets -->
<link media="all" href="http://netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" />
<link media="all" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
<link media="all" rel="stylesheet" href="/assets/css/site.css" />
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-59802572-1', 'auto');
    ga('send', 'pageview');

  </script>
</head>
<h1 id="sec74" class="chapter"><span style="font-weight:bold;font-size:medium;color:black">Chapter 7  문자열</span></h1>
<p><span style="font-size:medium">
</span><a id="strings"></a></p><span style="font-size:medium">
</span><h2 id="sec75" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.1   문자열은 순서(sequence)다.</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default320"></a><span style="font-size:medium">
</span><a id="hevea_default321"></a><span style="font-size:medium">
</span><a id="hevea_default322"></a><span style="font-size:medium">
</span><a id="hevea_default323"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">문자열은 여러 문자들의 순서다. 
꺾쇠 연산자로 한번에 하나씩 문자에 접근한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; letter = fruit[1]
</span></pre><p><a id="hevea_default324"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">두 번째 문장은 변수 <span style="font-family:monospace">fruit</span>에서 1번 위치 문자를 추출하여 변수 <span style="font-family:monospace">letter</span>에 대입한다.
꺾쇠 표현식을 인덱스(index)라고 부른다. 
인덱스는 순서(sequence)에서 사용자가 어떤 문자를 원하는지 표시한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">하지만, 여러분이 기대한 것은 아니다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; print letter
a
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">대부분의 사람에게 <code>'banana'</code>의 첫 분자는 <span style="font-family:monospace">a</span>가 아니라 <span style="font-family:monospace">b</span>다.
하지만, 파이썬 인텍스는 문자열 처음부터 오프셋(offset)</span><sup><a id="text8" href="#note8"><span style="font-weight:bold;font-size:medium;color:black">1</span></a></sup><span style="font-weight:bold;font-size:medium;color:black"> 이다. 
첫 글자 오프셋은 0 이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; print letter
b
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">그래서, <span style="font-family:monospace">b</span>가 <code>'banana'</code>의 0 번째 문자가 되고 <span style="font-family:monospace">a</span>가 첫번째, <span style="font-family:monospace">n</span>이 두번째 문자가 된다.</span></p><div class="center"><span style="font-weight:bold;font-size:medium;color:black"><img src="book009.png" /></span></div><p><a id="hevea_default325"></a><span style="font-size:medium">
</span><a id="hevea_default326"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">인덱스로 문자와 연산자를 포함하는 어떤 표현식도 사용가능지만, 인덱스 값은 정수여야만 한다.
정수가 아닌 경우 다음과 같은 결과를 얻게 된다.</span></p><p><a id="hevea_default327"></a><span style="font-size:medium">
</span><a id="hevea_default328"></a><span style="font-size:medium">
</span><a id="hevea_default329"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; letter = fruit[1.5]
TypeError: string indices must be integers
</span></pre><span style="font-size:medium">
</span><h2 id="sec76" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.2   <span style="font-family:monospace">len</span>함수 사용 문자열 길이 구하기</span></h2>
<p><a id="hevea_default330"></a><span style="font-size:medium">
</span><a id="hevea_default331"></a></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">len</span> 함수는 문자열의 문자 갯수를 반환하는 내장함수다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; len(fruit)
6
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">문자열의 가장 마지막 문자를 얻기 위해서, 아래와 같이 시도하려 싶을 것이다.</span></p><p><a id="hevea_default332"></a><span style="font-size:medium">
</span><a id="hevea_default333"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; length = len(fruit)
&gt;&gt;&gt; last = fruit[length]
IndexError: string index out of range
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">인덱스 오류 (IndexError)</span> 이유는 <span style="font-family:monospace">’banana’</span> 에 6번 인텍스 문자가 없기 때문이다.
0 에서부터 시작했기 때문에 6개 문자는 0 에서부터 5 까지 번호가 매겨졌다. 
마지막 문자를 얻기 위해서 <span style="font-family:monospace">length</span>에서 1을 빼야 한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; last = fruit[length-1]
&gt;&gt;&gt; print last
a
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">대안으로 음의 인텍스를 사용해서 문자열 끝에서 역으로 수를 셀 수 있다.
표현식 <span style="font-family:monospace">fruit[-1]</span>은 마지막 문자를 <span style="font-family:monospace">fruit[-2]</span>는 끝에서 두 번째 등등 활용할 수 있다.</span></p><p><a id="hevea_default334"></a><span style="font-size:medium">
</span><a id="hevea_default335"></a></p><span style="font-size:medium">
</span><h2 id="sec77" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.3   루프를 사용한 문자열 운행법</span></h2>
<p><span style="font-size:medium">
</span><a id="for"></a></p><p><a id="hevea_default336"></a><span style="font-size:medium">
</span><a id="hevea_default337"></a><span style="font-size:medium">
</span><a id="hevea_default338"></a><span style="font-size:medium">
</span><a id="hevea_default339"></a><span style="font-size:medium">
</span><a id="hevea_default340"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">연산의 많은 경우에 문자열을 한번에 한 문자씩 처리한다. 
종종 처음에서 시작해서, 차례로 각 문자를 선택하고, 선택된 문자에 임의 연산을 수행하고, 끝까지 계속한다. 
이런 처리 패턴을 운행법(traversal)라고 한다.
운행법을 작성하는 한 방법이 <span style="font-family:monospace">while</span> 루프다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">index = 0
while index &lt; len(fruit):
    letter = fruit[index]
    print letter
    index = index + 1
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">while</span> 루프가 문자열을 운행하여 문자열을 한줄에 한 글자씩 화면에 출력한다.
루프 조건이 <span style="font-family:monospace">index &lt; len(fruit)</span>이여서, <span style="font-family:monospace">index</span>가 문자열 길이와 같을 때,
조건은 거짓이 되고, 루프의 몸통 부문은 실행이 되지 않는다. 
파이썬이 접근한 마지막 <span style="font-family:monospace">len(fruit)-1</span> 인텍스 문자로, 문자열의 마지막 문자다.</span></p><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 1  <em>
문자열의 마지막 문자에서 시작해서, 문자열 처음으로 역진행하면서 한줄에 한자씩 화면에 출력하는 <span style="font-family:monospace">while</span> 루프를 작성하세요.
</em></span></div><p><span style="font-weight:bold;font-size:medium;color:black">운행법을 작성하는 또 다른 방법은 <span style="font-family:monospace">for</span> 루프다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">for char in fruit:
    print char
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">루프를 매번 반복할 때, 문자열 다음 문자가 변수 <span style="font-family:monospace">char</span>에 대입된다. 
루프는 더 이상 남겨진 문자가 없을 때까지 계속 실행된다.</span></p><span style="font-size:medium">
</span><h2 id="sec78" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.4   문자열 슬라이스(slice)</span></h2>
<p><span style="font-size:medium">
</span><a id="slice"></a></p><p><a id="hevea_default341"></a><span style="font-size:medium">
</span><a id="hevea_default342"></a><span style="font-size:medium">
</span><a id="hevea_default343"></a><span style="font-size:medium">
</span><a id="hevea_default344"></a><span style="font-size:medium">
</span><a id="hevea_default345"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">문자열의 일부분을 슬라이스(slice)라고 한다. 
문자열 슬라이스를 선택하는 것은 문자를 선택하는 것과 유사하다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; s = 'Monty Python'
&gt;&gt;&gt; print s[0:5]
Monty
&gt;&gt;&gt; print s[6:13]
Python
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">[n:m]</span> 연산자는 n번째 문자부터 m번째 문자까지의 문자열 - 첫 번째는 포함하지만 마지막은 제외 - 부분을 반환한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">콜론 앞 첫 인텍스를 생략하면, 문자열 슬라이스는 문자열 처음부터 시작한다.
두 번째 인텍스를 생략하면, 문자열 슬라이스는 문자열 끝까지 간다. </span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">만약 첫번째 인텍스가 두번째보다 크거나 같은 경우 결과는 인용부호로 표현되는 빈 문자열(empty string)이 된다.</span></p><p><a id="hevea_default346"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[3:3]
"
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">빈 문자열은 어떤 문자도 포함하지 않아서 길이가 0 이 되지만, 이것을 제외하고 다른 문자열과 동일하다.</span></p><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 2  
<em><span style="font-family:monospace">fruit</span>이 문자열로 주어졌을 때, <span style="font-family:monospace">fruit[:]</span>의 의미는 무엇인가요?</em></span><p><a id="hevea_default347"></a><span style="font-size:medium">
</span><a id="hevea_default348"></a></p></div><span style="font-size:medium">
</span><h2 id="sec79" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.5   문자열은 불변이다.</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default349"></a><span style="font-size:medium">
</span><a id="hevea_default350"></a><span style="font-size:medium">
</span><a id="hevea_default351"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">문자열 내부에 있는 문자를 변경하려고 대입문 왼쪽편에 <span style="font-family:monospace">[]</span> 연산자를 사용하고 싶은 유혹이 있을 것이다.
예를 들어 다음과 같다.</span></p><p><a id="hevea_default352"></a><span style="font-size:medium">
</span><a id="hevea_default353"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; greeting[0] = 'J'
TypeError: object does not support item assignment
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이 경우 ”객체(object)”는 문자열이고, 대입하고자 하는 문자는 ”항목(item)”이다. 
지금으로서 객체는 값과 동일하지만, 나중에 객체 정의를 좀더 상세화할 것이다.
항목은 순서 값 중의 하나다.</span></p><p><a id="hevea_default354"></a><span style="font-size:medium">
</span><a id="hevea_default355"></a><span style="font-size:medium">
</span><a id="hevea_default356"></a><span style="font-size:medium">
</span><a id="hevea_default357"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">오류 이유는 문자열은 불변(immutable)이기 때문이다. 
따라서 기존 문자열을 변경할 수 없다는 의미다.
최선의 방법은 원래 문자열을 변형한 새로운 문자열을 생성하는 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; new_greeting = 'J' + greeting[1:]
&gt;&gt;&gt; print new_greeting
Jello, world!
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">새로운 첫 문자에 <span style="font-family:monospace">greeting</span> 문자열 슬라이스를 연결한다. 
원래 문자열에는 어떤 영향도 주지 않는 새로운 문자열을 생성되었다.</span></p><p><a id="hevea_default358"></a></p><span style="font-size:medium">
</span><h2 id="sec80" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.6   루프 돌기(looping) 계수(counting)</span></h2>
<p><span style="font-size:medium">
</span><a id="counter"></a></p><p><a id="hevea_default359"></a><span style="font-size:medium">
</span><a id="hevea_default360"></a><span style="font-size:medium">
</span><a id="hevea_default361"></a><span style="font-size:medium">
</span><a id="hevea_default362"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">다음 프로그램은 문자열에 문자 <span style="font-family:monospace">a</span>가 나타나는 횟수를 계수한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print count
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 프로그램은 계수기(counter)라고 부르는 또다른 연산 패턴을 보여준다. 
변수 <span style="font-family:monospace">count</span>는 0 으로 초기화 되고, 매번 <span style="font-family:monospace">a</span>를 찾을 때마다 증가한다.
루프를 빠져나갔을 때, <span style="font-family:monospace">count</span>는 결과 값 즉, <span style="font-family:monospace">a</span>가 나타난 총 횟수를 담고 있다.</span></p><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 3  
</span><a id="hevea_default363"></a><p><span style="font-weight:bold;font-size:medium;color:black"><em>문자열과 문자를 인자(argument)로 받도록 상기 코드를 <span style="font-family:monospace">count</span>라는 함수로 캡슐화(encapsulation)하고 일반화하세요.</em></span></p></div><span style="font-size:medium">
</span><h2 id="sec81" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.7   <span style="font-family:monospace">in</span> 연산자</span></h2>
<p><span style="font-size:medium">
</span><a id="inboth"></a></p><p><a id="hevea_default364"></a><span style="font-size:medium">
</span><a id="hevea_default365"></a><span style="font-size:medium">
</span><a id="hevea_default366"></a><span style="font-size:medium">
</span><a id="hevea_default367"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">연산자 <span style="font-family:monospace">in</span> 은 불 연산자로 두 개의 문자열을 받아, 첫 번째 문자열이 두 번째 문자열의 일부이면 <span style="font-family:monospace">참(True)</span>을 반환한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; 'a' in 'banana'
True
&gt;&gt;&gt; 'seed' in 'banana'
False
</span></pre><span style="font-size:medium">
</span><h2 id="sec82" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.8   문자열 비교</span></h2>
<p><a id="hevea_default368"></a><span style="font-size:medium">
</span><a id="hevea_default369"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">비교 연산자도 문자열에서 동작한다. 
두 문자열이 같은지를 살펴보다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">if word == 'banana':
    print  'All right, bananas.'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">다른 비교 연산자는 단어를 알파벳 순서로 정렬하는데 유용하다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">if word &lt; 'banana':
    print 'Your word,' + word + ', comes before banana.'
elif word &gt; 'banana':
    print 'Your word,' + word + ', comes after banana.'
else:
    print 'All right, bananas.'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">파이썬은 사람과 동일하는 방식으로 대문자와 소문자를 다루지 않는다.
모든 대문자는 소문자 앞에 온다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">Your word, Pineapple, comes before banana.
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이러한 문제를 다루는 일반적인 방식은 비교 연산을 수행하기 전에 문자열을 표준 포맷으로 예를 들어 모두 소문자, 변환하는 것입니다.
경우에 따라서 ”Pineapple”로 무장한 사람들로부터 여러분을 보호해야하는 것을 명심하세요.</span></p><span style="font-size:medium">
</span><h2 id="sec83" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.9   <span style="font-family:monospace">string</span> 메쏘드</span></h2>
<p><span style="font-weight:bold;font-size:medium;color:black">
문자열은 파이썬 객체(objects)의 한 예다. 
객체는 데이터(실제 문자열 자체)와 메쏘드(methods)를 담고 있다.
메쏘드는 객체에 내장되고 어떤 객체의 인스턴스(instance)에도 사용되는 사실상 함수다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">객체에 대해 이용가능한 메쏘드를 보여주는 <span style="font-family:monospace">dir</span> 함수가 파이썬에 있다.
<span style="font-family:monospace">type</span> 함수는 객체의 자료형(type)을 보여 주고, <span style="font-family:monospace">dir</span>은 객체에 사용될 수 있는 메쏘드를 보여준다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; stuff = 'Hello world'
&gt;&gt;&gt; type(stuff)
&lt;type 'str'&gt;
&gt;&gt;&gt; dir(stuff)
['capitalize', 'center', 'count', 'decode', 'encode', 
'endswith', 'expandtabs', 'find', 'format', 'index', 
'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 
'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 
'partition', 'replace', 'rfind', 'rindex', 'rjust', 
'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 
'startswith', 'strip', 'swapcase', 'title', 'translate', 
'upper', 'zfill']
&gt;&gt;&gt; help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -&gt; string
    
    Return a copy of the string S with only its first character
    capitalized.
&gt;&gt;&gt;
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">dir</span> 함수가 메쏘드 목록을 보여주고, 메쏘드에 대한 간단한 문서 정보는 <span style="font-family:monospace">help</span>를 사용할 수 있지만,
문자열 메쏘드에 대한 좀더 좋은 문서 정보는 <span style="font-family:monospace">docs.python.org/library/string.html</span>에서 찾을 수 있다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">인자를 받고 값을 반환한다는 점에서 메쏘드(method)를 호출하는 것은 함수를 호출하는 것과 유사하지만, 구문은 다르다.
구분자로 점을 사용해서 변수명에 메쏘드명을 붙여 메쏘드를 호출한다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">예를 들어, <span style="font-family:monospace">upper</span> 메쏘드는 문자열을 받아 모두 대문자로 변환된 새로운 문자열을 반환한다.</span></p><p><a id="hevea_default370"></a><span style="font-size:medium">
</span><a id="hevea_default371"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">함수 구문 <span style="font-family:monospace">upper(word)</span> 대신에, <span style="font-family:monospace">word.upper()</span> 메쏘드 구문을 사용한다.</span></p><p><a id="hevea_default372"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; new_word = word.upper()
&gt;&gt;&gt; print new_word
BANANA
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">이런 형태의 점 표기법은 메쏘드 이름(<span style="font-family:monospace">upper</span>)과 메쏘드가 적용되는 문자열 이름(<span style="font-family:monospace">word</span>)을 명세한다.
빈 괄호는 메쏘드가 인자가 없다는 것을 나타낸다.</span></p><p><a id="hevea_default373"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">메쏘드를 부르는 것을 호출(invocation)이라고 부른다. 
상기의 경우, <span style="font-family:monospace">word</span>에 <span style="font-family:monospace">upper</span> 메쏘드를 호출한다고 말한다.</span></p><p><a id="hevea_default374"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">예를 들어, 문자열안에 문자열의 위치를 찾는 <span style="font-family:monospace">find</span>라는 문자열 메쏘드가 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; index = word.find('a')
&gt;&gt;&gt; print index
1
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 예제에서, <span style="font-family:monospace">word</span> 문자열의 <span style="font-family:monospace">find</span> 메쏘드를 호출하여 매개 변수로 찾고자 하는 문자를 넘긴다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">find</span> 메쏘드는 문자뿐만 아니라 부속 문자열(substring)도 찾을 수 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; word.find('na')
2
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">두 번째 인자로 어디서 검색을 시작할지 인텍스를 넣을 수 있다.</span></p><p><a id="hevea_default375"></a><span style="font-size:medium">
</span><a id="hevea_default376"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; word.find('na', 3)
4
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">한 가지 자주 있는 작업은 <span style="font-family:monospace">strip</span> 메쏘드를 사용해서 문자열 시작과 끝의 공백(공백 여러개, 탭, 새줄)을 제거하는 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; line = '  Here we go  '
&gt;&gt;&gt; line.strip()
'Here we go'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">startswith 메쏘드는 참, 거짓 같은 불 값(boolean value)을 반환한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; line = 'Please have a nice day'
&gt;&gt;&gt; line.startswith('Please')
True
&gt;&gt;&gt; line.startswith('p')
False
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">startswith가 대소문자를 구별하는 것을 요구하기 때문에 <span style="font-family:monospace">lower</span> 메쏘드를 사용해서 검증을 수행하기 전에, 
한 줄을 입력받아 모두 소문자로 변환하는 것이 필요하다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; line = 'Please have a nice day'
&gt;&gt;&gt; line.startswith('p')
False
&gt;&gt;&gt; line.lower()
'please have a nice day'
&gt;&gt;&gt; line.lower().startswith('p')
True
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">마지막 예제에서 문자열이 문자 ”p”로 시작하는지를 검증하기 위해서, 
<span style="font-family:monospace">lower</span> 메쏘드를 호출하고 나서 바로 <span style="font-family:monospace">startswith</span> 메쏘드를 사용한다.
주의깊게 순서만 다룬다면, 한 줄에 다수 메쏘드를 호출할 수 있다.</span></p><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 4  
</span><a id="hevea_default377"></a><span style="font-size:medium">
</span><a id="hevea_default378"></a><p><span style="font-weight:bold;font-size:medium;color:black"><em>앞선 예제와 유사한 함수인 <span style="font-family:monospace">count</span>로 불리는 문자열 메쏘드가 있다.
<span style="font-family:monospace">docs.python.org/library/string.html</span>에서 <span style="font-family:monospace">count</span> 메쏘드에 대한 문서를 읽고,
문자열 <code>'banana'</code>의 문자가 몇 개인지 계수하는 메쏘드 호출 프로그램을 작성하세요.</em></span></p></div><span style="font-size:medium">
</span><h2 id="sec84" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.10   문자열 파싱(Parsing)</span></h2>
<p><span style="font-weight:bold;font-size:medium;color:black">종종, 문자열을 들여다 보고 특정 부속 문자열(substring)을 찾고 싶다. 
예를 들어, 아래와 같은 형식으로 작성된 일련의 라인이 주어졌다고 가정하면,</span></p><pre><span style="font-weight:bold;font-size:large;color:blue">
From stephen.marquard@ uct.ac.za Sat Jan  5 09:14:16 2008
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">각 라인마다 뒤쪽 전자우편 주소(즉, <span style="font-family:monospace">uct.ac.za</span>)만 뽑아내고 싶을 것이다.
<span style="font-family:monospace">find</span> 메쏘드와 문자열 슬라이싱(string sliceing)을 사용해서 작업을 수행할 수 있다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">우선, 문자열에서 골뱅이(@, at-sign) 기호의 위치를 찾는다. 
그리고, 골뱅이 기호 <em>뒤</em> 첫 공백 위치를 찾는다. 
그리고 나서, 찾고자 하는 부속 문자열을 뽑아내기 위해서 문자열 슬라이싱을 사용한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; data = 'From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008'
&gt;&gt;&gt; atpos = data.find('@')
&gt;&gt;&gt; print atpos
21
&gt;&gt;&gt; sppos = data.find(' ',atpos)
&gt;&gt;&gt; print sppos
31
&gt;&gt;&gt; host = data[atpos+1:sppos]
&gt;&gt;&gt; print host
uct.ac.za
&gt;&gt;&gt; 
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">find</span> 메쏘드를 사용해서 찾고자 하는 문자열의 시작 위치를 명세한다. 
문자열 슬라이싱(slicing)할 때, 골뱅기 기호 뒤부터 빈 공백을 <em>포함하지 않는</em> 위치까지 문자열을 뽑아낸다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black"><span style="font-family:monospace">find</span> 메쏘드에 대한 문서는 <span style="font-family:monospace">docs.python.org/library/string.html</span>에서 참조 가능하다.</span></p><span style="font-size:medium">
</span><h2 id="sec85" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.11   서식 연산자</span></h2>
<p><a id="hevea_default379"></a><span style="font-size:medium">
</span><a id="hevea_default380"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">서식 연산자(format operator), <span style="font-family:monospace">%</span>는 문자열 일부를 변수에 저장된 값으로 바꿔 문자열을 구성한다.
정수에 서식 연산자가 적용될 때, <span style="font-family:monospace">%</span>는 나머지 연산자가 된다. 
하지만 첫 피연산자가 문자열이면, <span style="font-family:monospace">%</span>은 서식 연산자가 된다.</span></p><p><a id="hevea_default381"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">첫 피연산자는 서식 문자열 format string로 두번째 피연산자가 어떤 형식으로 표현되는지를 명세하는 하나 혹은 그 이상의 
서식 순서 format sequence를 담고 있다. 
결과값은 문자열이다.</span></p><p><a id="hevea_default382"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">예를 들어, 형식 순서 <code>'%d'</code>의 의미는 두번째 피연산자가 정수 형식으로 표현됨을 뜻한다. (<span style="font-family:monospace">d</span>는 “decimal”을 나타낸다.)</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">결과는 문자열 <code>'42'</code>로 정수 <span style="font-family:monospace">42</span>와 혼동하면 안 된다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">서식 순서는 문자열 어디에도 나타날 수 있어서 문장 중간에 값을 임베드(embed)할 수 있다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">만약 문자열 서식 순서가 하나 이상이라면, 두번째 인자는 튜플(tuple)이 된다.
서식 순서 각각은 순서대로 튜플 요소와 매칭된다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">다음 예제는 정수 형식을 표현하기 위해서 <code>'%d'</code>, 부동 소수점 형식을 표현하기 위해서 <code>'%g'</code>,
문자열 형식을 표현하기 위해서 <code>'%s'</code>을 사용한 사례다. 
여기서 왜 부동 소수점 형식이 <code>'%f'</code>대신에 <code>'%g'</code>인지는 질문하지 말아주세요.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">튜플 요소 숫자는 문자열 서식 순서의 숫자와 일치해야 하고, 요소의 자료형(type)도 서식 순서와 일치해야 한다.</span></p><p><a id="hevea_default383"></a><span style="font-size:medium">
</span><a id="hevea_default384"></a></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: illegal argument type for built-in operation
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">상기 첫 예제는 충분한 요소 개수가 되지 않고, 두 번째 예제는 자료형이 맞지 않는다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">서식 연산자는 강력하지만, 사용하기가 어럽다.
더 많은 정보는 <span style="font-family:monospace">docs.python.org/lib/typesseq-strings.html</span>에서 찾을 수 있다.</span></p><span style="font-size:medium">
</span><h2 id="sec86" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.12   디버깅</span></h2>
<p><span style="font-size:medium">
</span><a id="hevea_default385"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">프로그램을 작성하면서 배양해야 하는 기술은 항상 자신에게 질문을 하는 것이다.
”여기서 무엇이 잘못 될 수 있을까?” 혹은 ”내가 작성한 완벽한 프로그램을 망가뜨리기 위해 사용자는 무슨 엄청난 일을 할 것인가?"</span></p><p><span style="font-weight:bold;font-size:medium;color:black">예를 들어 앞장의 반복 <span style="font-family:monospace">while</span> 루프를 시연하기 위해 사용한 프로그램을 살펴봅시다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">while True:
    line = raw_input('&gt; ')
    if line[0] == '#' :
        continue
    if line == 'done':
        break
    print line

print 'Done!'
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">사용자가 입력값으로 빈 공백 줄을 입력하게 될 때 무엇이 발생하는지 살펴봅시다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">&gt; hello there
hello there
&gt; # don't print this
&gt; print this!
print this!
&gt; 
Traceback (most recent call last):
  File "copytildone.py", line 3, in &lt;module&gt;
    if line[0] == '#' :
</span></pre><p><span style="font-weight:bold;font-size:medium;color:black">빈 공백줄이 입력될 때까지 코드는 잘 작동합니다. 
그리고 나서, 0 번째 문자가 없어서 트레이스백(traceback)이 발생한다. 
입력줄이 비어있을 때, 코드 3번째 줄을 ”안전”하게 만드는 두 가지 방법이 있다.</span></p><p><span style="font-weight:bold;font-size:medium;color:black">하나는 빈 문자열이면 <span style="font-family:monospace">거짓(False)</span>을 반환하도록 <span style="font-family:monospace">startswith</span> 메쏘드를 사용하는 것이다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">    if line.startswith('#') :
</span></pre><p><a id="hevea_default386"></a><span style="font-size:medium">
</span><a id="hevea_default387"></a></p><p><span style="font-weight:bold;font-size:medium;color:black">가디언 패턴(guardian pattern)을 사용한 <span style="font-family:monospace">if</span>문으로 문자열에 적어도 하나의 문자가 있는 경우만 두번째 논리 표현식이 평가되도록 코드를 작성한다.</span></p><pre class="verbatim"><span style="font-weight:bold;font-size:large;color:blue">    if len(line) &gt; 0 and line[0] == '#' :
</span></pre><span style="font-size:medium">
</span><h2 id="sec87" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.13   용어정의</span></h2>
<dl class="description"><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">계수기(counter):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 무언가를 계수하기 위해서 사용되는 변수로 일반적으로 0 으로 초기화하고 나서 증가한다.
</span><a id="hevea_default388"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">빈 문자열(empty string):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 두 인용부호로 표현되고, 어떤 문자도 없고 길이가 0 인 문자열.
</span><a id="hevea_default389"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">서식 연산자(format operator):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 서식 문자열과 튜플을 받아, 서식 문자열에 지정된 서식으로 튜플 요소를 포함하는 문자열을 생성하는 연산자, <span style="font-family:monospace">%</span>.
</span><a id="hevea_default390"></a><span style="font-size:medium">
</span><a id="hevea_default391"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">서식 순서(format sequence):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> <span style="font-family:monospace">%d</span>처럼 어떤 값의 서식으로 표현되어야 하는지를 명세하는 ”서식 문자열” 문자 순서. 
</span><a id="hevea_default392"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">서식 문자열(format string):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 서식 순서를 포함하는 서식 연산자와 함께 사용되는 문자열.
</span><a id="hevea_default393"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">플래그(flag):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 조건이 참인지를 표기하기 위해 사용하는 불 변수(boolean variable)
</span><a id="hevea_default394"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">호출(invocation):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 메쏘드를 호출하는 명령문.
</span><a id="hevea_default395"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">불변(immutable):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 순서의 항목에 대입할 수 없는 특성.
</span><a id="hevea_default396"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">인덱스(index):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 문자열의 문자처럼 순서(sequence)에 항목을 선택하기 위해 사용되는 정수 값.
</span><a id="hevea_default397"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">항목(item):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 순서에 있는 값의 하나.
</span><a id="hevea_default398"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">메쏘드(method):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 객체와 연관되어 점 표기법을 사용하여 호출되는 함수.
</span><a id="hevea_default399"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">객체(object):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 변수가 참조하는 무엇. 지금은 ”객체”와 ”값”을 구별없이 사용한다.
</span><a id="hevea_default400"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">검색(search):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 찾고자 하는 것을 찾았을 때 멈추는 운행법 패턴.
</span><a id="hevea_default401"></a><span style="font-size:medium">
</span><a id="hevea_default402"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">순서(sequence):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 정돈된 집합. 즉, 정수 인텍스로 각각의 값이 확인되는 값의 집합.
</span><a id="hevea_default403"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">슬라이스(slice):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 인텍스 범위로 지정되는 문자열 부분.
</span><a id="hevea_default404"></a></dd><dt class="dt-description"><span style="font-weight:bold;font-size:medium;color:black">운행법(traverse):</span></dt><dd class="dd-description"><span style="font-weight:bold;font-size:medium;color:black"> 순서(sequence)의 항목을 반복적으로 훑기, 각각에 대해서는 동일한 연산을 수행.
</span><a id="hevea_default405"></a></dd></dl><span style="font-size:medium">
</span><h2 id="sec88" class="section"><span style="font-weight:bold;font-size:medium;color:black">7.14   연습문제</span></h2>
<div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 5  <em>
다음 문자열을 파이썬 코드를 작성하세요.</em></span><pre><span style="font-weight:bold;font-size:large;color:blue"><em>
str = ’X-DSPAM-Confidence:  0.8475’
</em></span></pre><p><span style="font-weight:bold;font-size:medium;color:black"><em><span style="font-family:monospace">find</span> 메쏘드와 문자열 슬라이싱을 사용하여 콜론(:) 문자 뒤 문자열을 뽑아내고 
<span style="font-family:monospace">float</span> 함수를 사용하여 뽑아낸 문자열을 부동 소수점 숫자로 변환하세요.</em></span></p></div><div class="theorem"><span style="font-weight:bold;font-size:medium;color:black">Exercise 6  
</span><a id="hevea_default406"></a><span style="font-size:medium">
</span><a id="hevea_default407"></a><p><span style="font-weight:bold;font-size:medium;color:black"><em><span style="font-family:monospace">https://docs.python.org/2.7/library/stdtypes.html#string-methods</span>에서 문자열 메쏘드 문서를 읽어보세요.
어떻게 동작하는가를 이해도를 확인하기 위해서 몇개를 골라 실험을 해보세요.
<span style="font-family:monospace">strip</span>과 <span style="font-family:monospace">replace</span>가 특히 유용합니다.</em></span></p><p><span style="font-weight:bold;font-size:medium;color:black"><em>문서는 좀 혼동스러울 수 있는 구문을 사용합니다.
예를 들어, <code>find(sub[, start[, end]])</code>의 꺾쇠기호는 선택(옵션) 인수를 나타냅니다.
그래서, <span style="font-family:monospace">sub</span>은 필수지만, <span style="font-family:monospace">start</span>은 선택 사항이고, 만약 <span style="font-family:monospace">start</span>가 인자로 포함된다면, <span style="font-family:monospace">end</span>는 선택이 된다. 
</em></span></p></div><span style="font-size:medium">
</span><hr class="footnoterule" /><dl class="thefootnotes"><dt class="dt-thefootnotes"><span style="font-size:medium">
</span><a id="note8" href="#text8"><span style="font-weight:bold;font-size:medium;color:black">1</span></a></dt><dd class="dd-thefootnotes"><span style="font-weight:bold;font-size:medium;color:black"><div class="footnotetext">컴퓨터에서 어떤 주소로부터 간격을 두고 떨어진 주소와의 거리. 기억 장치가 페이지 혹은 세그먼트 단위로 나누어져 있을 때 하나의 시작 주소로부터 오프셋만큼 떨어진 위치를 나타내는 것이다. [네이버 지식백과] 오프셋 [offset] (IT용어사전, 한국정보통신기술협회)</div>
</span></dd></dl>
<footer class="footer">
<div class="container">
<div class="row">
<div class="col-lg-offset-3 col-lg-6">
<div class="row">
<div class="col-xs-12 text-center">
<small>&copy; rifyll theme, 2014, 
                Powered by <a href="http://www.ibm.com/cloud-computing/kr/ko/softlayer/"><img src="/img/softlayer.png" width="47" height="23" alt="hosting services" /></a> </small>
</div>
</div>
</div>
</div>
</div>
</footer>
<hr />
<a href="book007.html"><img src="previous_motif.gif" alt="Previous" /></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up" /></a>
<a href="book009.html"><img src="next_motif.gif" alt="Next" /></a>
</body>
</html>
